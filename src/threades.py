#! /usr/bin/env python##   Author : Mohit Taneja (mohitgenii@gmail.com)#   Date : 9/06/2008 ##   This program is free software; you can redistribute it and/or modify#   it under the terms of the GNU General Public License as published by#   the Free Software Foundation; either version 2 of the License, or#   (at your option) any later version.##   This program is distributed in the hope that it will be useful,#   but WITHOUT ANY WARRANTY; without even the implied warranty of#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the#   GNU General Public License for more details.##   You should have received a copy of the GNU General Public License#   along with this program; if not, write to the Free Software#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.#import model             import initial           import Exceptions        import facilities        import indicators         import threading      from time import sleep,time,ctime# import statements for animation classesimport pygameimport osfrom pygame.locals import *pygame.init()from load_images import *print 'threades''''initialization of money '''money=model.Money()def initialize_facilities():        for i in range(initial.INIT_HOUSE):        build_facility(House)    for i in range(initial.INIT_HOSPITAL):        build_facility(Hospital)    for i in range(initial.INIT_SCHOOL):        build_facility(School)    for i in range(initial.INIT_FARM):        build_facility(Farm)    for i in range(initial.INIT_FOUNTAIN):        build_facility(Fountain)    for i in range(initial.INIT_WORKSHOP):        build_facility(Workshop)            Water.set_variables('WATER',initial.INIT_WATER,initial.INIT_M_WATER,initial.COST_WATER)    Buildmat.set_variables('BUILDING MATERIAL',initial.INIT_BUILDMAT,initial.INIT_M_BUILDMAT,initial.COST_BUILDMAT)    Tools.set_variables('TOOLS',initial.INIT_TOOLS,initial.INIT_M_TOOLS,initial.COST_TOOLS)    transform_obj.focus_at((0,0))    transform_obj.set_ratio(0.2)'''  initialization of facilities   '''#houseHouse = model.Facility('HOUSE',facilities.COST_HOUSE,facilities.COST_LEVEL_HOUSE,facilities.PROD_HOUSE,facilities.CONS_HOUSE,0,0)#schoolSchool = model.Facility('SCHOOL',facilities.COST_SCHOOL,facilities.COST_LEVEL_SCHOOL,facilities.PROD_SCHOOL,facilities.CONS_SCHOOL,0,0)#hospitalHospital = model.Facility('HOSPITAL',facilities.COST_HOSPITAL,facilities.COST_LEVEL_HOSPITAL,facilities.PROD_HOSPITAL,facilities.CONS_HOSPITAL,0,0)#farmFarm = model.Facility('FARM',facilities.COST_FARM,facilities.COST_LEVEL_FARM,facilities.PROD_FARM,facilities.CONS_FARM,0,0)#workshopWorkshop = model.Facility('WORKSHOP',facilities.COST_WORKSHOP,facilities.COST_LEVEL_WORKSHOP,facilities.PROD_WORKSHOP,facilities.CONS_WORKSHOP,0,0)#fountainFountain = model.Facility('FOUNTAIN',facilities.COST_FOUNTAIN,facilities.COST_LEVEL_FOUNTAIN,facilities.PROD_FOUNTAIN,facilities.CONS_FOUNTAIN,0,0)''' initialization of resources   '''#waterWater=model.Resource('WATER',initial.INIT_WATER,initial.INIT_M_WATER,initial.COST_WATER)#building materialBuildmat=model.Resource('BUILDING MATERIAL',initial.INIT_BUILDMAT,initial.INIT_M_BUILDMAT,initial.COST_BUILDMAT)#toolsTools=model.Resource('TOOLS',initial.INIT_TOOLS,initial.INIT_M_TOOLS,initial.COST_TOOLS)#medicinesMedicine=model.Resource('MEDICINE',initial.INIT_MEDICINE,initial.INIT_M_MEDICINE,initial.COST_MEDICINE)#booksBook=model.Resource('BOOKS',initial.INIT_BOOKS,initial.INIT_M_BOOKS,initial.COST_BOOKS)#riceRice=model.Resource('RICE',initial.INIT_RICE,initial.INIT_M_RICE,initial.COST_RICE)#wheatWheat=model.Resource('WHEAT',initial.INIT_WHEAT,initial.INIT_M_WHEAT,initial.COST_WHEAT)#beansBeans=model.Resource('BEANS',initial.INIT_BEANS,initial.INIT_M_BEANS,initial.COST_BEANS)#sugarSugar=model.Resource('SUGAR',initial.INIT_SUGAR,initial.INIT_M_SUGAR,initial.COST_SUGAR)#saltSalt=model.Resource('SALT',initial.INIT_SALT,initial.INIT_M_SALT,initial.COST_SALT)#oilOil=model.Resource('OILS',initial.INIT_OILS,initial.INIT_M_OILS,initial.COST_OILS)''' initialization of indicators  '''#housingHousing=model.Indicator('HOUSING',initial.INIT_HOUSING,indicators.PDICT_HOUSING)#healthHealth=model.Indicator('HEALTH',initial.INIT_HEALTH,indicators.PDICT_HEALTH)#educationEducation=model.Indicator('EDUCATION',initial.INIT_EDUCATION,indicators.PDICT_EDUCATION)#nutritionNutrition=model.Indicator('NUTRITION',initial.INIT_NUTRITION,indicators.PDICT_NUTRITION)#trainingTraining=model.Indicator('TRAINING',initial.INIT_TRAINING,indicators.PDICT_TRAINING)# A Switch for pausing the update threadupdate_thread_pause = True'''initialisation of manpower resources'''ppl = model.People(initial.INIT_PEOPLE, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)'''initialisation of lists'''resources=(Water,Buildmat,Tools,Medicine,Book,Rice,Wheat,Beans,Sugar,Salt,Oil)  # resources listfood_resources=(Rice,Wheat,Beans,Sugar,Salt,Oil)  #food resources listfacilities_list=(House,School,Hospital,Workshop,Farm,Fountain) #facilities listindicators_list=(Housing,Nutrition,Health,Education,Training) #indicators list''' List of all the sprites '''house_sprite_list = []hospital_sprite_list = []workshop_sprite_list = []school_sprite_list = []farm_sprite_list = []fountain_sprite_list = []facilities_list_sprites = { 'HOUSE':house_sprite_list, 'HOSPITAL':hospital_sprite_list, 'FARM':farm_sprite_list, 'SCHOOL':school_sprite_list, 'WORKSHOP':workshop_sprite_list, 'FOUNTAIN':fountain_sprite_list}''' Definition of threads'''def stop_facility(facility_obj):    ''' Thread to stop a facility it resumes the facility when the village    has enough resources to run the facility    '''    global resources    message.push_message('Facility '+facilities.FACILITY_NAMES[facility_obj.get_name()]+' has been temporarily stopped due to insufficient resources to run the facility','high')    res_cost = facility_obj.get_consumption()    facility_obj.stop_facility()    a=1    while True:        a=0                for i in range(len(resources)):            name = resources[i].get_name()            if res_cost.has_key(name):                if resources[i].get_vquantity() < res_cost[name]:                    a=1        if a==0:            break        sleep(2)    facility_obj.resume_facility()    message.push_message('Facility '+facilities.FACILITY_NAMES[facility_obj.get_name()]+' has been resumed','low')        print 'Facility : ' , facility_obj.get_name() , ' resumed'def get_setup_text(facility_obj):        text = ''    text += 'Number -'    text += str(int(facility_obj.get_number()))    text += '   Level -'    text += str(int(facility_obj.get_number()))    text +='\n'    cost_build = facility_obj.get_cost_build()    text +='Resources required to build :  BUILDING MATERIAL-'+str(int(cost_build['BUILDING MATERIAL']))+' TOOLS -'+str(int(cost_build['TOOLS']))+' WATER -'+str(int(cost_build['WATER']))+'\n'    cost_run = facility_obj.get_cons_dict()    if cost_run:        text +='Resources required to run : '        for key in cost_run.keys():            text +=key+'- '+str(int(cost_run[key]))+' '        text +='\n'    text +='Manpower required : To build- '+str(int(facilities.FACILITY_MANP_DICT_BUILD[facility_obj.get_name()]['EMPLOYED PEOPLE IN CONSTRUCTION']))+' To run- '    if facilities.FACILITY_MANP_DICT_RUN[facility_obj.get_name()]:        for key in facilities.FACILITY_MANP_DICT_RUN[facility_obj.get_name()].keys():            text +=str(int(facilities.FACILITY_MANP_DICT_RUN[facility_obj.get_name()][key]))    else:        text += '0'        return textdef build_facility(facility_obj, list_food = ('0')):    ''' Thread to build a new building of any facility    '''    global resources    global ppl        try:                resources=facility_obj.build_start(resources,ppl)                if facility_obj.get_name() == 'FARM':            print ' enter the amount of various food products that you will like to grow in the farm (in percentage) '            qrice = int(raw_input(' Rice: '))            qwheat = int(raw_input(' Wheat: '))            qbeans = int(raw_input(' Beans: '))            qsugar = int(raw_input(' Sugar: '))            qsalt = int(raw_input(' Salt: '))            qoils = int(raw_input(' Oils: '))            qrice = qrice*facilities.MAX_FOOD_PROD_PER_FARM/100            qwheat = qwheat*facilities.MAX_FOOD_PROD_PER_FARM/100            qbeans = qbeans*facilities.MAX_FOOD_PROD_PER_FARM/100            qsugar = qsugar*facilities.MAX_FOOD_PROD_PER_FARM/100            qsalt = qsalt*facilities.MAX_FOOD_PROD_PER_FARM/100            qoils = qoils*facilities.MAX_FOOD_PROD_PER_FARM/100            prod = facility_obj.get_prod_dict()            prod['RICE'] = (prod['RICE']*facility_obj.get_number() + qrice)/(facility_obj.get_number() + 1)            prod['WHEAT'] = (prod['WHEAT']*facility_obj.get_number() + qwheat)/(facility_obj.get_number() + 1)            prod['BEANS'] = (prod['BEANS']*facility_obj.get_number() + qbeans)/(facility_obj.get_number() + 1)            prod['SUGAR'] = (prod['SUGAR']*facility_obj.get_number() + qsugar)/(facility_obj.get_number() + 1)            prod['SALT'] = (prod['SALT']*facility_obj.get_number() + qsalt)/(facility_obj.get_number() + 1)            prod['OILS'] = (prod['OILS']*facility_obj.get_number() + qoils)/(facility_obj.get_number() + 1)            facility_obj.set_consumption(prod)                               ppl = facility_obj.update_manp_res(ppl)                    except Exceptions.Resources_Underflow_Exception:        return 'You dont have enough resources to build the facility,  please try later'    except Exceptions.Low_Manpower_Resources_Exception:        return 'You dont have enough manpower to build the facility, please try later'    except Exceptions.Maximum_Number_Reached:        return 'You cannot setup more buildings of this facility, try setting up some other facility'        print 'drawing first phase of facility-',facility_obj.get_name()    print 'drawing second phase of facility-',facility_obj.get_name()    print 'drawing third phase of facility-',facility_obj.get_name()    print 'drawing fourth phase of facility-',facility_obj.get_name()        #ppl = facility_obj.build_end(ppl)    if facility_obj.get_name() == 'HOUSE':        sprite = House_sprite()        house_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)    if facility_obj.get_name() == 'HOSPITAL':        sprite = Hospital_sprite()        hospital_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)    if facility_obj.get_name() == 'WORKSHOP':        sprite = Workshop_sprite()        workshop_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)    if facility_obj.get_name() == 'SCHOOL':        sprite = School_sprite()        school_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)    if facility_obj.get_name() == 'FARM':        sprite = Farm_sprite()        farm_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)    if facility_obj.get_name() == 'FOUNTAIN':        sprite = Fountain_sprite()        fountain_sprite_list.append(sprite)        add_sprite_all(sprite)        add_sprite_facilities(sprite)        print 'FACILITY MADE', facility_obj.get_name()        return 'Facility has been build'def build_end_facility(facility_obj):    global ppl    ppl = facility_obj.build_end(ppl)def upgrade_facility(facility_obj):    ''' Upgrades a facility    COMMENT : change the view of facility if you want to do so    '''    if facility_obj.get_number() == 0:        print  facility_obj.get_original_number()        if facility_obj.get_original_number() > 0:            text = 'You cannot upgrade a facility when it has been temporarily stopped, try upgrading it when it is resumed'            return text        text = 'You need to setup a facility first to upgrade it'        return text            global resources    try:        resources = facility_obj.update_level(resources,ppl)    except Exceptions.Resources_Underflow_Exception:        text =  "You don't have enough resources to upgrade the facility please try later"        return text    except Exceptions.Maximum_Level_Reached:        text =  'Facility has reached its maximum level you cant upgrade it now'        return text        print 'Updation of facility started',facility_obj.get_name()        # Updation of sprites    for i in range(len(facilities_list_sprites[facility_obj.get_name()])):        facilities_list_sprites[facility_obj.get_name()][i].upgrade_level()        text = 'Facility has been upgraded'    return textdef pause_update_thread():    global update_thread_pause    update_thread_pause = Falsedef resume_update_thread():    global update_thread_pause    update_thread_pause = Truedef update_turn():    ''' Updates the resources, facilities, manpower resources and indicators    at each turn    '''    global resources    global facilities_list    global ppl    global food_resources    global Housing    global Nutrition    global Health    global Water    global School        while True:        print update_thread_pause        if update_thread_pause == True:            # updation of all facilities            for i in range(len(facilities_list)):                try:                    resources = facilities_list[i].turn(resources)                except Exceptions.Resources_Underflow_Exception:                    print ' you dont have enough resources to run the facility' , facilities_list[i].get_name(), ' it is being stopped temporarily'                    t = threading.Thread(target = stop_facility , args = [facilities_list[i]])                    t.start()                except Exceptions.Resources_Overflow_Exception:                    pass                 # updation of manpower resources                                   resources = ppl.update_turn(resources,facilities_list)                            # updation of prices of resources and the check on resources if their market value decreases a certain value then it should increase it                        for i in range(len(resources)):                resources[i].update_price()                if resources[i].get_mquantity < 500:                    resources[i].change_mquantity(8000)                                # updation of indicators                # housing            ratio_people_sheltered = ppl.get_no_of_ppl_sheltered()/ppl.get_total_population()            Housing.turn({'SHELTERED PEOPLE' : ratio_people_sheltered})                # nutrition            ppl_fed_ratio = ppl.get_no_of_ppl_fed()/ppl.get_total_population()            temp = initial.FOOD_DIST_DICT            protiens = 0            vitamins = 0            fats = 0            for resource in food_resources:                name = resource.get_name()                if temp.has_key(name):                    protiens += temp[name]['PROTIENS'] * resource.get_vquantity()                    vitamins += temp[name]['VITAMINS'] * resource.get_vquantity()                    fats += temp[name]['FATS'] * resource.get_vquantity()                                        food = protiens + vitamins + fats            protiens /= food            vitamins /= food            fats /= food                Nutrition.turn({'PEOPLE FED' : ppl_fed_ratio , 'PROTIENS' : protiens , 'FATS' : fats , 'VITAMINS' : vitamins})                # health            healthy_ppl_ratio = ppl.get_no_of_ppl_healthy()/ppl.get_total_population()            nutrition = Nutrition.get_value()            nutrition /= initial.MAX_INDICATOR            water = Water.get_vquantity()/initial.MAX_RES_VAL_VILLAGE                Health.turn({'HEALTHY PEOPLE' : healthy_ppl_ratio , 'NUTRITION' : nutrition , 'WATER' : water})                # education            educated_ppl = ppl.get_no_of_ppl_educated()/ppl.get_total_population()            level = School.get_level()/initial.MAX_LEVELS_FACILITY            Education.turn({'EDUCATED PEOPLE' : educated_ppl , 'LEVEL OF EDUCATION' : level })                # training            level = Workshop.get_level()/initial.MAX_LEVELS_FACILITY            ppl_workshop = ppl.get_no_of_ppl_emp_in_workshop()/ppl.get_total_population()            ppl_farm = ppl.get_no_of_ppl_emp_in_farm()/ppl.get_total_population()                ppl_hospital = ppl.get_no_of_ppl_emp_in_hospital()/ppl.get_total_population()            ppl_construction = ppl.get_no_of_ppl_emp_in_cons()/ppl.get_total_population()            Training.turn({ 'LEVEL OF WORKSHOPS' : level , 'EMPLOYED PEOPLE IN WORKSHOP' : ppl_workshop , 'EMPLOYED PEOPLE IN FARM' : ppl_farm , 'EMPLOYED PEOPLE IN HOSPITAL' : ppl_hospital , 'EMPLOYED PEOPLE IN CONSTRUCTION' : ppl_construction })            sleep(3)            # Functions for making the code resolution independentoriginal_screen_size = (1200.0,900.0)new_screen_size = (1024,768)def resize_pos(original_pos,original_size = original_screen_size,new_size = new_screen_size):    ratio_x = (original_pos[0]+0.0)/(original_size[0]+0.0)     ratio_y = original_pos[1]/(original_size[1] +0.0)    new_pos = (int(new_size[0]*ratio_x),int(new_size[1]*ratio_y))    return new_posdef resize_pt(point,original_size = original_screen_size,new_size = new_screen_size):    ratio_x = new_size[0]/(original_size[0]+0.0)     ratio_y = new_size[1]/(original_size[1] +0.0)    ratio = (ratio_x + ratio_y)/2    point *= ratio    return int(point)def resize_pt_x(point,original_size = original_screen_size,new_size = new_screen_size):    ratio_x = new_size[0]/(original_size[0]+0.0)     point *= ratio_x    return int(point)def resize_pt_y(point,original_size = original_screen_size,new_size = new_screen_size):    ratio_y = new_size[1]/(original_size[1] +0.0)    point *= ratio_y    return int(point)    def resize_rect(original_rect,original_size = original_screen_size,new_size = new_screen_size):    ratio_x = new_size[0]/(original_size[0]+0.0)     ratio_y = new_size[1]/(original_size[1] +0.0)    new_rect = (int(original_rect[0]*ratio_x),int(original_rect[1]*ratio_y),int(original_rect[2]*ratio_x),int(original_rect[3]*ratio_y))    return new_rect    def buy_res(res,res_quantity):    ''' This method allows a user to buy resources    '''    global resources    global money            try:        #print "The initial value of resources with the village is" , resources[i].get_vquantity()        #print "The initial value of resources with the market is" , resources[i].get_mquantity()        quantity=res_quantity        #print 'initial money is'        #print money.get_money()        money = res.buy(quantity , money)        #print 'final money is'        #print money.get_money()        #print "The final value of resources with the village is" , resources[i].get_vquantity()        #print "The final value of resources with the market is" , resources[i].get_mquantity()    except Exceptions.Money_Underflow_Exception:        text ='You dont have enough money to buy this resource. Please change the quantity or try later'        return text    except Exceptions.Resources_Underflow_Exception:        text ='The market doesnot have enough quantity to sell this resource to village'        return text    except Exceptions.Resources_Overflow_Exception:        text ='The Village cannot store so much amount of resources you should try and use the money to buy some other resources '        return text            text = 'The Village has bought the resource you demanded'    return text                def sell_res(res,res_quantity):    ''' This method allows a user to sell resources    '''    global resources    global money                try:        #print "The initial value of resources with the village is" , resources[i].get_vquantity()        #print "The initial value of resources with the market is" , resources[i].get_mquantity()        quantity=res_quantity        money = res.sell(quantity , money)                #print "The final value of resources with the village is" , resources[i].get_vquantity()        #print "The final value of resources with the market is" , resources[i].get_mquantity()    except Exceptions.Resources_Underflow_Exception:        text = 'The village doesnot have enough quantity to sell this resource to market'        return text    except Exceptions.Resources_Overflow_Exception:        text = 'The Village has sold the resource you demanded'        return text    text = 'The Village has sold the resource you demanded'    return text                               def earthquake():    ''' This method needs to be called when there is an earthquake in the     village, it decreases the number of installations of some facilities and     also reduce the population    '''        global Hospital     global House    global School    global Workshop    global ppl        Hospital.demolish()    House.demolish()    House.demolish()    House.demolish()        School.demolish()    Workshop.demolish()    ppl.change_total_population(-10)        def flood():    '''This method needs to be called when there is an flood in the village    It will increase the quantity of water with the village and stop the operation of    all facilities for some time    '''    global Hospital     global House    global School    global Workshop    global ppl    global Water    global Farm            try :        Water.change_vquantity(1000)    except :        pass        Hospital.stop_facility()    House.stop_facility()  # we can comment it out even....    School.stop_facility()    Workshop.stop_facility()    Farm.stop_facility()         sleep(90)                   # that means for five turns        Hospital.resume_facility()    House.resume_facility()    School.resume_facility()    Workshop.resume_facility()    Farm.resume_facility()        def famine():    '''This method needs to be called when there is an famine in the village    It will stop the production of farms for some time, five turns    '''        global Farm        Farm.stop_facility()    sleep(90)    Farm.resume_facility()    # The messages Classes    class Messages:    ''' Class which handles the messaging system    '''    def __init__(self):        self.queue = []        self.queue_color = []                def push_message(self,text,priority):        ''' Used to push a message in the message queue        '''        if priority == 'low':            color = (0,127,0) # Green        if priority == 'medium':            color = (0,0,127) # Blue        if priority == 'high':            color = (127,0,0) # Red                self.queue_color.append(color)        self.queue.append(text)        def pop_message(self):        ''' Used to pop a message from the message queue        '''                text = None        color = None        if self.queue:            text = self.queue.pop(0)            color = self.queue_color.pop(0)        return (text,color)        message = Messages()   # the Mesages class object # NOW there are classes of animation and sprites hereclass Workshop_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        workshop_posn_list = [(7500,550),(8265,50),(6700,50),(6700,1050),(8265,1050)]        # Saving tiles of all the upgrades in tiles_list        self.frame = 0        self.level = Workshop.get_level()        self.built_flag = 0        transform_obj.focus_at(workshop_posn_list[Workshop.get_number()-1])        self.image = transform_obj.transform_surface(Workshop_tiles_list[self.level][self.frame])        self.rect = self.image.get_rect()        self.position = workshop_posn_list[Workshop.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 4 and self.level ==0) :                if (self.frame == 4 and self.built_flag == 0) :                    build_end_facility(Workshop)                    self.built_flag = 1            elif (self.frame >= 2 and self.level ==1) :                pass            elif (self.frame >= 2 and self.level ==2) :                pass            elif (self.frame >= 2 and self.level ==3) :                pass            else:                self.frame += 1                    self.image = transform_obj.transform_surface(Workshop_tiles_list[self.level][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)    def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(Workshop_tiles_list[self.level][self.frame])            def upgrade_level(self):        self.level +=1        self.counter = 4        self.frame = 0  class House_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        house_posn_list = [(200,500),(700,1000),(200,1000),(700,500),(1200,500),(1200,1000),(200,1500),(700,1500),(1200,1500)]        # Saving tiles of all the upgrades in tiles_list        self.frame = 0        self.level = House.get_level()        self.built_flag = 0        print House.get_number()        print house_posn_list[House.get_number()-1]        transform_obj.focus_at(house_posn_list[House.get_number()-1])        self.image = transform_obj.transform_surface(House_tiles_list[self.level][self.frame])        self.rect = self.image.get_rect()        self.position = house_posn_list[House.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 4 and self.level ==0) :                if (self.frame == 4 and self.built_flag == 0) :                    build_end_facility(House)                    self.built_flag = 1            elif (self.frame >= 2 and self.level ==1) :                pass            elif (self.frame >= 2 and self.level ==2) :                pass            elif (self.frame >= 2 and self.level ==3) :                pass            else:                self.frame += 1                    self.image = transform_obj.transform_surface(House_tiles_list[self.level][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)    def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(House_tiles_list[self.level][self.frame])            def upgrade_level(self):        self.level +=1        self.counter = 4        self.frame = 0        class Hospital_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        hospital_posn_list = [(200,2000),(700,2000),(1200,2000),(1700,300),(1700,800),(1700,1200),(2200,2200),(300,800)]        # Saving tiles of all the upgrades in tiles_list        self.frame = 0        self.level = Hospital.get_level()        self.built_flag = 0        transform_obj.focus_at(hospital_posn_list[Hospital.get_number()-1])        self.image = transform_obj.transform_surface(Hospital_tiles_list[self.level][self.frame])        self.rect = self.image.get_rect()        self.position = hospital_posn_list[Hospital.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 4 and self.level ==0) :                if (self.frame == 4 and self.built_flag == 0) :                    build_end_facility(Hospital)                    self.built_flag = 1            elif (self.frame >= 2 and self.level ==1) :                pass            elif (self.frame >= 2 and self.level ==2) :                pass            elif (self.frame >= 2 and self.level ==3) :                pass            else:                self.frame += 1                    self.image = transform_obj.transform_surface(Hospital_tiles_list[self.level][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)    def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(Hospital_tiles_list[self.level][self.frame])              def upgrade_level(self):        self.level +=1        self.counter = 4        self.frame = 0                class School_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        school_posn_list = [(2200,1500),(2200,1000),(300,2500),(800,2500),(1300,2500),(1800,2500),(300,800)]        # Saving tiles of all the upgrades in tiles_list                        self.frame = 0        self.level = School.get_level()        self.built_flag =0        transform_obj.focus_at(school_posn_list[School.get_number()-1])        self.image = transform_obj.transform_surface(School_tiles_list[self.level][self.frame])        self.rect = self.image.get_rect()        self.position = school_posn_list[School.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 4 and self.level ==0) :                if (self.frame == 4 and self.built_flag == 0) :                    build_end_facility(School)                    self.built_flag = 1            elif (self.frame >= 2 and self.level ==1) :                pass            elif (self.frame >= 2 and self.level ==2) :                pass            elif (self.frame >= 2 and self.level ==3) :                pass            else:                self.frame += 1                    self.image = transform_obj.transform_surface(School_tiles_list[self.level][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)    def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(School_tiles_list[self.level][self.frame])                    def upgrade_level(self):        self.level +=1        self.counter = 4        self.frame = 0 class Farm_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        farm_posn_list = [(850,50),(300,800),(200,500),(300,800),(200,500),(300,800),(200,500),(300,800)]        # Saving tiles of all the upgrades in tiles_list        self.frame = 0        self.built_flag = 0        transform_obj.focus_at(farm_posn_list[Farm.get_number()-1])        self.image = transform_obj.transform_surface(Farm_tiles[0][self.frame])        self.rect = self.image.get_rect()        self.position = farm_posn_list[Farm.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 2) :                if (self.frame == 2 and self.built_flag == 0) :                    build_end_facility(Farm)                    self.built_flag = 1            else:                self.frame += 1                    self.image = transform_obj.transform_surface(Farm_tiles[0][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)      def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(Farm_tiles[0][self.frame])              def upgrade_level(self):        pass    class Fountain_sprite(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        fountain_posn_list = [(500,3000),(800,3000),(1200,3000),(1600,3000),(2000,3000),(2300,3000),(200,500),(300,800)]        # Saving tiles of all the upgrades in tiles_list        self.frame = 0        self.built_flag = 0        transform_obj.focus_at(fountain_posn_list[Fountain.get_number()-1])        print len(Fountain_tiles[0])        self.image = transform_obj.transform_surface(Fountain_tiles[0][self.frame])        self.rect = self.image.get_rect()        self.position = fountain_posn_list[Fountain.get_number()-1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)        self.counter = 0    def update(self):        if self.counter < 10:            self.counter += 1        else:            self.counter = 0                        if (self.frame >= 3) :                if (self.frame == 3 and self.built_flag == 0) :                    build_end_facility(Fountain)                    self.built_flag = 1            else:                self.frame += 1                    self.image = transform_obj.transform_surface(Fountain_tiles[0][self.frame])        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)      def set_frame(self, frame):        self.frame = frame        self.image = transform_obj.transform_surface(Fountain_tiles[0][self.frame])              def upgrade_level(self):        passclass Environment(pygame.sprite.Sprite):        def __init__(self):        pygame.sprite.Sprite.__init__(self)        spritesheet = Spritesheet('tileset.png')        self.tiles = spritesheet.imgat((0,0,1200,560))                    def get_background(self):                background = pygame.Surface((1200,560)).convert()        print 'initialised background surface'        background.blit(self.tiles, (0,0))             print ' after for loop '        return background                class Build(pygame.sprite.Sprite):        def __init__(self, filename, x, y, colorkey=None):        pygame.sprite.Sprite.__init__(self)        self.market_image = pygame.image.load(os.path.join('data', filename)).convert_alpha()        self.image = transform_obj.transform_surface(self.market_image)        if colorkey is not None:            if colorkey is -1:                colorkey = self.image.get_at((0, 0))            self.image.set_colorkey(colorkey, RLEACCEL)        self.rect = self.image.get_rect()        self.x = x        self.y = y        self.rect = self.rect.move(transform_obj.transform_cordinates((x, y)))        self.prev_disp = transform_obj.transform_cordinates((x, y))            def update(self):        self.image = transform_obj.transform_surface(self.market_image)        self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.rect = self.rect.move(transform_obj.transform_cordinates((self.x, self.y)))        self.prev_disp = transform_obj.transform_cordinates((self.x,self.y))                def add_sprite_all(sprite):    sprite.add(all)        def add_sprite_facilities(sprite):    sprite.add(facilities_group)    class Villager(pygame.sprite.Sprite):        def __init__(self, name):        pygame.sprite.Sprite.__init__(self)        self.dx = 2        self.dy = 0        self.speed = [2, 0]                if name == 'Man':            self.tiles = Man_tiles                if name == 'Woman':            self.tiles = Woman_tiles                if name == 'Boy':            self.tiles = Boy_tiles                if name == 'Girl':            self.tiles = Girl_tiles                self.frame = 0        self.set_direction()        self.image = self.tiles[self.frame]        self.rect = self.image.get_rect()        position = (300+int(random.random()*600), 240+int(random.random()*100))        self.rect = self.rect.move(transform_obj.transform_cordinates(position))        self.prev_disp = transform_obj.transform_cordinates(position)        self.counter = 0        def set_direction(self):        sp = self.speed        if sp[0] > 0  and sp[1] == 0:            self.dtiles = self.tiles[0:4]        elif sp[0] < 0  and sp[1] == 0:            self.dtiles = self.tiles[4:8]        elif sp[0] == 0  and sp[1] > 0:            self.dtiles = self.tiles[8:12]        elif sp[0] == 0  and sp[1] < 0:            self.dtiles = self.tiles[12:16]                def collide_build(self):        #self.rect = self.rect.move([-2*self.speed[0], -2*self.speed[1]])        self.set_speed(map(lambda x: -x, self.speed))    def collide_villager(self):        sp = self.speed        dx = self.dx        dy = self.dy        if sp[0] < 0  and sp[1] < 0:            self.speed = [dx, dy]        elif sp[0] > 0  and sp[1] > 0:            self.speed = [-dx, -dy]        elif sp[0] > 0  and sp[1] < 0:            self.speed = [-dx, dy]        elif sp[0] < 0  and sp[1] > 0:            self.speed = [dx, -dy]                      self.set_direction()        def set_speed(self, speed):        self.speed = speed        self.set_direction()        def update(self):            self.counter +=1        ANIMRECT = Rect(0,0,9000,6000)        if self.frame == 2:            self.frame = 0        else:            self.frame  += 1                if self.counter >= 100:            temp = self.speed[0]            self.speed[0] = self.speed[1]            self.speed[1] = temp            self.set_direction()                self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))        self.image = self.dtiles[self.frame]        self.position[0] += self.speed[0]        self.position[1] += self.speed[1]        self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))        self.prev_disp = transform_obj.transform_cordinates(self.position)                if self.rect.left <= 0 or self.rect.right >= ANIMRECT.width:            self.speed[0] = -self.speed[0]            self.set_direction()            self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))            self.image = self.dtiles[self.frame]            self.position[0] += self.speed[0]            self.position[1] += self.speed[1]            self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))            self.prev_disp = transform_obj.transform_cordinates(self.position)                    elif self.rect.top <= 0 or self.rect.bottom >= ANIMRECT.height:            self.speed[1] = -self.speed[1]            self.set_direction()            self.rect = self.rect.move((-self.prev_disp[0],-self.prev_disp[1]))            self.image = self.dtiles[self.frame]            self.position[0] += self.speed[0]            self.position[1] += self.speed[1]            self.rect = self.rect.move(transform_obj.transform_cordinates(self.position))            self.prev_disp = transform_obj.transform_cordinates(self.position)                    self.rect.clamp_ip(ANIMRECT)            class Transform:    def __init__(self):        self.pos_x = 0        self.pos_y = 0        self.ratio = 0.2        self.motion_up = 0        self.motion_down = 0        self.motion_left = 0        self.motion_right = 0               def move_up(self,dist = 10):                self.pos_y -= dist        def start_move(self,dir):                    if dir == 'up':            self.motion_up = 1        elif dir == 'down':            self.motion_down = 1        elif dir == 'right':            self.motion_right = 1        elif dir == 'left':            self.motion_left = 1      def stop_move(self,dir):                    if dir == 'up':            self.motion_up = 0        elif dir == 'down':            self.motion_down = 0        elif dir == 'right':            self.motion_right = 0        elif dir == 'left':            self.motion_left = 0      def move(self):        if self.motion_up:            self.pos_y -=10        if self.motion_down:            self.pos_y +=10        if self.motion_right:            self.pos_x+=10        if self.motion_left:            self.pos_x -=10      def move_mouse(self,(x,y)):            self.pos_x -= x        self.pos_y -=y     def move_down(self):                self.pos_y += 10      def move_right(self,dist = 10):                self.pos_x += dist          def move_left(self,dist = 10):                self.pos_x -= dist            def check_pos(self):        if self.pos_x < 0:            self.pos_x = 0        if self.pos_x > (int(self.ratio*9000) - 1200):            self.pos_x = (int(self.ratio*9000) - 1200)        if self.pos_y < 0:            self.pos_y = 0        if self.pos_y > (int(self.ratio*6000) - 560):            self.pos_y = (int(self.ratio*6000) - 560)                    def focus(self):        ''' Used to focus or zoom in'''        self.ratio = self.ratio + 0.10        if self.ratio >= 1.0:            self.ratio = 1.0        else:            a = self.pos_x +600            b = self.pos_y + 280            a *= self.ratio/(self.ratio - 0.10)            b *= self.ratio/(self.ratio - 0.10)            self.pos_x = int(a - 600)            self.pos_y = int(b - 280)            def defocus(self):        ''' Used to defocus or zoom out'''        self.ratio = self.ratio - 0.10        if self.ratio <= 0.2:            self.ratio = 0.2        else:            a = self.pos_x +600            b = self.pos_y + 280            a *= self.ratio/(self.ratio + 0.10)            b *= self.ratio/(self.ratio + 0.10)            self.pos_x = int(a - 600)            self.pos_y = int(b - 280)            def focus_at(self,(x,y)):        '''Used to focus at a particular position'''        self.ratio = 0.8        self.pos_x = int(x*self.ratio) -200        self.pos_y = int(y*self.ratio) - 20      def transform_cordinates(self,(x,y)):        newx = x*self.ratio - self.pos_x        newy = y*self.ratio - self.pos_y        return (int(newx),int(newy))     def set_ratio(self,ratio):        self.ratio = ratio      def transform_surface(self,surface):        (x,y) = surface.get_size()        x *= self.ratio        y *= self.ratio        newsurface = pygame.transform.scale(surface, (int(x),int(y)))        return newsurface             class Animation:        def __init__(self):        global surface3        print ' initialising surface'        print 'initialising environment'        env = Environment()        print 'after constructor'        self.background = env.get_background()        print'blitting background to the surface'        surface3.blit(self.background,(0,0))        print'drawing all sprites on the surface'        mkt = Build('market.png',5000,3000)        mkt.add(all,market)        all.draw(surface3)         def update(self):        ''' Creates the final surface with the background and all and with the sprites too '''                global surface3        transform_obj.move()        transform_obj.check_pos()         all.clear(surface3,self.background)        all.update()        all.draw(surface3)        all = pygame.sprite.RenderUpdates() facilities_group = pygame.sprite.Group()market = pygame.sprite.Group()transform_obj = Transform()surface3 = pygame.surface.Surface((1200,560))    